# 需要在 Tailwindcss 提取的时候，获取更多的元数据

## 需要知道更多信息



现在的情况， `tailwindcss` 在从文件/内容中提取出 `Candidate` 的时候，是仅仅提取出一些字符串的信息。

但是，假如后续有对原先源代码最终生成产物修改的需求，我们就需要知道，它原先提取的位置，比如下方这样一个对象

```ts
interface Candidate {
  value: string
  file: string
  start: number
  end: number
}
```

其中 `value` 就是原先字符串的值，`file` 就是从什么文件中提取的，然后 `start` 和 `end` 代表这个 `token` 在文件中的一个位置

这样我们就能进行精确的修改，比如:

```diff filename="diff"
// before
- const className = `gap-y-4 bg-zinc-800/30`;
// after
+ const className = `a b`;
```


不然现在去进行修改的话，只能所有的文件都去应用 整个 `Candidates` \(`Set<string>`\) 进行替换来修改，这往往会导致很多的误伤。

而有了这个，我们只需要找到对应的文件，修改它的 `start` 和 `end` 对应的节点就能达到目的了

其实这个功能最终就有些类似于 `unocss` 的这个功能 https://unocss.dev/transformers/compile-class

{/* https://github.com/tailwindlabs/tailwindcss/blob/437579d3f010a98ae4b824a7d5694486119fbdcd/packages/%40tailwindcss-postcss/src/index.ts#L157 */}

## Tailwindcss v3



## Tailwindcss v4

https://github.com/tailwindlabs/tailwindcss/blob/437579d3f010a98ae4b824a7d5694486119fbdcd/crates/oxide/src/lib.rs#L108

```rs
    pub fn scan(&mut self) -> Vec<String> {
        init_tracing();
        self.prepare();
        self.check_for_new_files();
        self.compute_candidates();

        let mut candidates: Vec<String> = self.candidates.clone().into_iter().collect();

        candidates.sort();

        candidates
    }
```